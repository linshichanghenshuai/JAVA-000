###### （初步版本到时候再继续补充）

###### 串行GC（Serial）

新生代采用复制算法，老年代采用标记-整理算法，就是一个单线程的收集器，只是用一条线程去执行垃圾收集任务，而在他执行时会STW导致其他线程无法工作直到收集结束。

![image-20201028225024669](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20201028225024669.png)



###### ParNew GC

就是串行GC的多线程版本，就是用多个线程去收集垃圾，其他和串行GC并无太大区别。新生代采用复制算法，老年代采用标记-整理算法。一般会结合CMS GC使用，在CMS GC不指定年轻代收集器默认就是这个收集器作为年轻代收集器。



![image-20201028225322015](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20201028225322015.png)



###### Parallel GC

该收集器关注的是吞吐量（CPU中用于运行用户代码的时间与CPU总消耗时间的比值）也是JDK8默认的GC，新生代采用复制算法，老年代采用标记-整理算法。

![image-20201028225948302](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20201028225948302.png)



###### CMS GC

是一种以获取最短回收停顿时间为目标的收集器。它而非常符合在注重用户体验的应用上使用，它是HotSpot虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。



 初始标记: 暂停所有的其他线程(STW)，并记录下直接与root相连的对象，速度很快 ；

 并发标记：同时开启GC和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以GC线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。

 重新标记：重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短

并发清除：开启用户线程，同时GC线程开始对未标记的区域做清扫

![image-20201028230205983](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20201028230205983.png)

所以该GC的优点的并发的执行,且停顿时间短，对用户来说体验比较好.但是该GC采用的是标记-清除算法会产生大量的空间碎片，且无法清除业务线程与垃圾清除线程并发执行时产生的垃圾（浮动垃圾），只能等下一次GC清理。

###### G1 GC

G1将Java堆划分为多个大小相等的独立区域（Region），虽保留新生代和老年代的概念，但不再是物理隔阂了，它们都是（可以不连续）Region的集合。分配大对象（直接进Humongous区，专门存放短期巨型对象，不用直接进老年代，避免Full GC的大量开销）不会因为无法找到连续空间而提前触发下一次GC。

G1相对于CMS的另一个大优势，降低停顿时间是G1 和 CMS 共同的关注点，但G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内完成垃圾收集

 初始标记（initial mark，STW）：在此阶段，G1 GC 对根进行标记。该阶段与常规的 (STW) 年轻代垃圾回收密切相关。

 并发标记（Concurrent Marking）：G1 GC 在整个堆中查找可访问的（存活的）对象。

 最终标记（Remark，STW）：该阶段是 STW 回收，帮助完成标记周期。

 筛选回收（Cleanup，STW）：筛选回收阶段首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划，这个阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅提高收集效率。

![image-20201028231545312](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20201028231545312.png)

G1自己在后台维护了一个优先列表，会根据允许的时间来回收价值最大的空间(其实就是占的内存比较大的数据)

###### GC的选择

单核或者，数据量比较小的时候用串行GC。

要求高吞吐量的话使用JDK8默认的并行收集器

如果要求停顿时间短的话就是用CMS或者G1。